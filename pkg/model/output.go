// Package model defines output data abstractions for different analysis types.
package model

import (
	"encoding/json"
	"sort"
)

// AnalysisDataType represents the type of analysis data.
type AnalysisDataType string

const (
	DataTypeCPUProfiling AnalysisDataType = "cpu_profiling"
	DataTypeAllocation   AnalysisDataType = "allocation"
	DataTypeHeapDump     AnalysisDataType = "heap_dump"
	DataTypeMemoryLeak   AnalysisDataType = "memory_leak"
	DataTypeTracing      AnalysisDataType = "tracing"
)

// OutputFile describes an output file generated by analysis.
type OutputFile struct {
	Name        string `json:"name"`         // Descriptive name (e.g., "Flame Graph", "Heap Report")
	LocalPath   string `json:"local_path"`   // Local file path
	COSKey      string `json:"cos_key"`      // Object storage key
	ContentType string `json:"content_type"` // MIME type
}

// TopItem represents a generic top item (function/class/object).
type TopItem struct {
	Name       string                 `json:"name"`
	Value      int64                  `json:"value"`      // Sample count / bytes / instance count
	Percentage float64                `json:"percentage"` // Percentage of total
	Extra      map[string]interface{} `json:"extra,omitempty"`
}

// AnalysisData is the interface for all analysis data types.
// Different analysis types implement this interface to provide
// type-specific data while maintaining a common abstraction.
type AnalysisData interface {
	// Type returns the analysis data type.
	Type() AnalysisDataType

	// Summary returns a summary of the analysis as key-value pairs.
	Summary() map[string]interface{}

	// TopItems returns the top items (functions, classes, etc.) from the analysis.
	TopItems() []TopItem
}

// CPUProfilingData holds CPU profiling analysis data.
type CPUProfilingData struct {
	FlameGraphFile string       `json:"flamegraph_file"`
	CallGraphFile  string       `json:"callgraph_file"`
	ThreadStats    []ThreadInfo `json:"thread_stats"`
	TopFuncs       TopFuncsMap  `json:"top_funcs"`
	TotalSamples   int64        `json:"total_samples"`
}

// Type returns the analysis data type.
func (d *CPUProfilingData) Type() AnalysisDataType {
	return DataTypeCPUProfiling
}

// Summary returns a summary of the CPU profiling analysis.
func (d *CPUProfilingData) Summary() map[string]interface{} {
	return map[string]interface{}{
		"total_samples":   d.TotalSamples,
		"thread_count":    len(d.ThreadStats),
		"flamegraph_file": d.FlameGraphFile,
		"callgraph_file":  d.CallGraphFile,
	}
}

// TopItems returns the top functions from CPU profiling.
func (d *CPUProfilingData) TopItems() []TopItem {
	items := make([]TopItem, 0, len(d.TopFuncs))
	for name, val := range d.TopFuncs {
		items = append(items, TopItem{
			Name:       name,
			Percentage: val.Self,
		})
	}
	// Sort by percentage descending
	sort.Slice(items, func(i, j int) bool {
		return items[i].Percentage > items[j].Percentage
	})
	return items
}

// AllocationData holds memory allocation analysis data.
type AllocationData struct {
	FlameGraphFile   string       `json:"flamegraph_file"`
	CallGraphFile    string       `json:"callgraph_file"`
	ThreadStats      []ThreadInfo `json:"thread_stats"`
	TopAllocators    TopFuncsMap  `json:"top_allocators"`
	TotalAllocations int64        `json:"total_allocations"`
	TotalBytes       int64        `json:"total_bytes,omitempty"`
}

// Type returns the analysis data type.
func (d *AllocationData) Type() AnalysisDataType {
	return DataTypeAllocation
}

// Summary returns a summary of the allocation analysis.
func (d *AllocationData) Summary() map[string]interface{} {
	return map[string]interface{}{
		"total_allocations": d.TotalAllocations,
		"total_bytes":       d.TotalBytes,
		"thread_count":      len(d.ThreadStats),
		"flamegraph_file":   d.FlameGraphFile,
		"callgraph_file":    d.CallGraphFile,
	}
}

// TopItems returns the top allocators from allocation analysis.
func (d *AllocationData) TopItems() []TopItem {
	items := make([]TopItem, 0, len(d.TopAllocators))
	for name, val := range d.TopAllocators {
		items = append(items, TopItem{
			Name:       name,
			Percentage: val.Self,
		})
	}
	sort.Slice(items, func(i, j int) bool {
		return items[i].Percentage > items[j].Percentage
	})
	return items
}

// HeapClassStats holds statistics for a single class in heap analysis.
type HeapClassStats struct {
	ClassName     string         `json:"class_name"`
	InstanceCount int64          `json:"instance_count"`
	TotalSize     int64          `json:"total_size"`
	Percentage    float64        `json:"percentage"`
	RetainedSize  int64          `json:"retained_size,omitempty"` // Dominator tree retained size
	Retainers     []HeapRetainer `json:"retainers,omitempty"`
	GCRootPaths   []*GCRootPath  `json:"gc_root_paths,omitempty"` // Sample paths to GC roots
}

// HeapRetainer describes what retains instances of a class.
type HeapRetainer struct {
	RetainerClass string  `json:"retainer_class"`
	FieldName     string  `json:"field_name,omitempty"`
	RetainedSize  int64   `json:"retained_size"`
	RetainedCount int64   `json:"retained_count"`
	Percentage    float64 `json:"percentage"`
	Depth         int     `json:"depth,omitempty"` // Distance from target (1 = direct, 2+ = indirect)
}

// GCRootPathNode represents a node in a GC root path.
type GCRootPathNode struct {
	ClassName string `json:"class_name"`
	FieldName string `json:"field_name,omitempty"`
	Size      int64  `json:"size"`
}

// GCRootPath represents a path from GC Root to an object.
type GCRootPath struct {
	RootType string            `json:"root_type"`
	Path     []*GCRootPathNode `json:"path"`
	Depth    int               `json:"depth"`
}

// HeapReferenceNode represents a node in the reference graph visualization.
type HeapReferenceNode struct {
	ID           string `json:"id"`
	ClassName    string `json:"class_name"`
	Size         int64  `json:"size"`
	RetainedSize int64  `json:"retained_size"`
	IsGCRoot     bool   `json:"is_gc_root"`
	GCRootType   string `json:"gc_root_type,omitempty"`
}

// HeapReferenceEdge represents an edge in the reference graph visualization.
type HeapReferenceEdge struct {
	Source    string `json:"source"`
	Target    string `json:"target"`
	FieldName string `json:"field_name,omitempty"`
}

// HeapReferenceGraph represents the reference graph for a class.
type HeapReferenceGraph struct {
	ClassName string              `json:"class_name"`
	Nodes     []HeapReferenceNode `json:"nodes"`
	Edges     []HeapReferenceEdge `json:"edges"`
}

// HeapBusinessRetainer represents a business-level class that retains memory.
type HeapBusinessRetainer struct {
	ClassName     string   `json:"class_name"`
	FieldPath     []string `json:"field_path"`
	RetainedSize  int64    `json:"retained_size"`
	RetainedCount int64    `json:"retained_count"`
	Percentage    float64  `json:"percentage"`
	Depth         int      `json:"depth"`
	IsGCRoot      bool     `json:"is_gc_root"`
	GCRootType    string   `json:"gc_root_type,omitempty"`
}

// HeapBiggestObject represents a large object with its details.
type HeapBiggestObject struct {
	ObjectID     string              `json:"object_id"`
	ClassName    string              `json:"class_name"`
	ShallowSize  int64               `json:"shallow_size"`
	RetainedSize int64               `json:"retained_size"`
	Fields       []HeapObjectField   `json:"fields,omitempty"`
	GCRootPath   *HeapGCRootPath     `json:"gc_root_path,omitempty"`
}

// HeapObjectField represents a field value in an object.
type HeapObjectField struct {
	Name         string      `json:"name"`
	Type         string      `json:"type"`
	Value        interface{} `json:"value,omitempty"`
	RefID        string      `json:"ref_id,omitempty"`
	RefClass     string      `json:"ref_class,omitempty"`
	ShallowSize  int64       `json:"shallow_size,omitempty"`
	RetainedSize int64       `json:"retained_size,omitempty"`
	HasChildren  bool        `json:"has_children,omitempty"`
	IsStatic     bool        `json:"is_static,omitempty"`
}

// HeapGCRootPath represents a path from GC Root to an object.
type HeapGCRootPath struct {
	RootType string               `json:"root_type"`
	Path     []HeapGCRootPathNode `json:"path"`
	Depth    int                  `json:"depth"`
}

// HeapGCRootPathNode represents a node in a GC root path.
type HeapGCRootPathNode struct {
	ClassName string `json:"class_name"`
	FieldName string `json:"field_name,omitempty"`
	Size      int64  `json:"size"`
}

// HeapGCRootsData holds GC roots analysis data for persistence.
// This is written to gc_roots.json during analysis for fast loading in serve mode.
type HeapGCRootsData struct {
	Summary HeapGCRootsSummary  `json:"summary"`
	Classes []HeapGCRootClass   `json:"classes"`
}

// HeapGCRootsSummary holds summary statistics for GC roots.
type HeapGCRootsSummary struct {
	TotalRoots    int   `json:"total_roots"`
	TotalClasses  int   `json:"total_classes"`
	TotalRetained int64 `json:"total_retained"`
	TotalShallow  int64 `json:"total_shallow"`
}

// HeapGCRootClass represents GC roots grouped by class name (like IDEA).
type HeapGCRootClass struct {
	ClassName     string               `json:"class_name"`
	RootType      string               `json:"root_type,omitempty"` // Primary root type (most common)
	TotalShallow  int64                `json:"total_shallow"`
	TotalRetained int64                `json:"total_retained"`
	InstanceCount int                  `json:"instance_count"`
	Roots         []HeapGCRootInstance `json:"roots,omitempty"` // Individual GC root instances
}

// HeapGCRootInstance represents a single GC root instance.
type HeapGCRootInstance struct {
	ObjectID     string `json:"object_id"`
	RootType     string `json:"root_type"`
	ShallowSize  int64  `json:"shallow_size"`
	RetainedSize int64  `json:"retained_size"`
	ThreadID     string `json:"thread_id,omitempty"`
	FrameIndex   int    `json:"frame_index,omitempty"`
}

// HeapAnalysisData holds Java heap dump analysis data.
type HeapAnalysisData struct {
	HeapReportFile    string                           `json:"heap_report_file"`
	HistogramFile     string                           `json:"histogram_file"`
	Format            string                           `json:"format,omitempty"`
	IDSize            int                              `json:"id_size,omitempty"`
	Timestamp         int64                            `json:"timestamp,omitempty"`
	TotalClasses      int                              `json:"total_classes"`
	TotalInstances    int64                            `json:"total_instances"`
	TotalHeapSize     int64                            `json:"total_heap_size"`
	HeapSizeHuman     string                           `json:"heap_size_human"`
	LiveBytes         int64                            `json:"live_bytes,omitempty"`
	LiveObjects       int64                            `json:"live_objects,omitempty"`
	TopClasses        []HeapClassStats                 `json:"top_classes"`
	BiggestObjects    []HeapBiggestObject              `json:"biggest_objects,omitempty"`
	ReferenceGraphs   map[string]*HeapReferenceGraph   `json:"reference_graphs,omitempty"`
	BusinessRetainers map[string][]HeapBusinessRetainer `json:"business_retainers,omitempty"`
}

// Type returns the analysis data type.
func (d *HeapAnalysisData) Type() AnalysisDataType {
	return DataTypeHeapDump
}

// Summary returns a summary of the heap analysis.
func (d *HeapAnalysisData) Summary() map[string]interface{} {
	return map[string]interface{}{
		"format":           d.Format,
		"id_size":          d.IDSize,
		"timestamp":        d.Timestamp,
		"total_classes":    d.TotalClasses,
		"total_instances":  d.TotalInstances,
		"total_heap_size":  d.TotalHeapSize,
		"heap_size_human":  d.HeapSizeHuman,
		"live_bytes":       d.LiveBytes,
		"live_objects":     d.LiveObjects,
		"heap_report_file": d.HeapReportFile,
		"histogram_file":   d.HistogramFile,
	}
}

// TopItems returns the top classes from heap analysis.
func (d *HeapAnalysisData) TopItems() []TopItem {
	items := make([]TopItem, 0, len(d.TopClasses))
	for _, cls := range d.TopClasses {
		items = append(items, TopItem{
			Name:       cls.ClassName,
			Value:      cls.TotalSize,
			Percentage: cls.Percentage,
			Extra: map[string]interface{}{
				"instance_count": cls.InstanceCount,
			},
		})
	}
	return items
}

// MemoryLeakData holds memory leak analysis data.
type MemoryLeakData struct {
	LeakReportFile  string       `json:"leak_report_file"`
	AllocationFile  string       `json:"allocation_file"`
	LeakSuspects    []LeakInfo   `json:"leak_suspects"`
	TopAllocators   TopFuncsMap  `json:"top_allocators"`
	TotalLeakBytes  int64        `json:"total_leak_bytes"`
	TotalLeakCount  int64        `json:"total_leak_count"`
	ThreadStats     []ThreadInfo `json:"thread_stats,omitempty"`
}

// LeakInfo holds information about a potential memory leak.
type LeakInfo struct {
	Location    string  `json:"location"`
	LeakBytes   int64   `json:"leak_bytes"`
	LeakCount   int64   `json:"leak_count"`
	Percentage  float64 `json:"percentage"`
	Description string  `json:"description,omitempty"`
}

// Type returns the analysis data type.
func (d *MemoryLeakData) Type() AnalysisDataType {
	return DataTypeMemoryLeak
}

// Summary returns a summary of the memory leak analysis.
func (d *MemoryLeakData) Summary() map[string]interface{} {
	return map[string]interface{}{
		"total_leak_bytes":  d.TotalLeakBytes,
		"total_leak_count":  d.TotalLeakCount,
		"suspect_count":     len(d.LeakSuspects),
		"leak_report_file":  d.LeakReportFile,
		"allocation_file":   d.AllocationFile,
	}
}

// TopItems returns the top leak suspects.
func (d *MemoryLeakData) TopItems() []TopItem {
	items := make([]TopItem, 0, len(d.LeakSuspects))
	for _, leak := range d.LeakSuspects {
		items = append(items, TopItem{
			Name:       leak.Location,
			Value:      leak.LeakBytes,
			Percentage: leak.Percentage,
			Extra: map[string]interface{}{
				"leak_count":  leak.LeakCount,
				"description": leak.Description,
			},
		})
	}
	return items
}

// TracingData holds tracing analysis data.
type TracingData struct {
	FlameGraphFile string       `json:"flamegraph_file"`
	CallGraphFile  string       `json:"callgraph_file"`
	ThreadStats    []ThreadInfo `json:"thread_stats"`
	TopFuncs       TopFuncsMap  `json:"top_funcs"`
	TotalSamples   int64        `json:"total_samples"`
}

// Type returns the analysis data type.
func (d *TracingData) Type() AnalysisDataType {
	return DataTypeTracing
}

// Summary returns a summary of the tracing analysis.
func (d *TracingData) Summary() map[string]interface{} {
	return map[string]interface{}{
		"total_samples":   d.TotalSamples,
		"thread_count":    len(d.ThreadStats),
		"flamegraph_file": d.FlameGraphFile,
		"callgraph_file":  d.CallGraphFile,
	}
}

// TopItems returns the top functions from tracing.
func (d *TracingData) TopItems() []TopItem {
	items := make([]TopItem, 0, len(d.TopFuncs))
	for name, val := range d.TopFuncs {
		items = append(items, TopItem{
			Name:       name,
			Percentage: val.Self,
		})
	}
	sort.Slice(items, func(i, j int) bool {
		return items[i].Percentage > items[j].Percentage
	})
	return items
}

// MarshalJSON implements custom JSON marshaling for AnalysisData.
func MarshalAnalysisData(data AnalysisData) ([]byte, error) {
	if data == nil {
		return []byte("null"), nil
	}

	wrapper := struct {
		Type string      `json:"type"`
		Data interface{} `json:"data"`
	}{
		Type: string(data.Type()),
		Data: data,
	}

	return json.Marshal(wrapper)
}

// UnmarshalAnalysisData unmarshals JSON into the appropriate AnalysisData type.
func UnmarshalAnalysisData(data []byte) (AnalysisData, error) {
	if len(data) == 0 || string(data) == "null" {
		return nil, nil
	}

	var wrapper struct {
		Type string          `json:"type"`
		Data json.RawMessage `json:"data"`
	}

	if err := json.Unmarshal(data, &wrapper); err != nil {
		return nil, err
	}

	var result AnalysisData
	switch AnalysisDataType(wrapper.Type) {
	case DataTypeCPUProfiling:
		var d CPUProfilingData
		if err := json.Unmarshal(wrapper.Data, &d); err != nil {
			return nil, err
		}
		result = &d
	case DataTypeAllocation:
		var d AllocationData
		if err := json.Unmarshal(wrapper.Data, &d); err != nil {
			return nil, err
		}
		result = &d
	case DataTypeHeapDump:
		var d HeapAnalysisData
		if err := json.Unmarshal(wrapper.Data, &d); err != nil {
			return nil, err
		}
		result = &d
	case DataTypeMemoryLeak:
		var d MemoryLeakData
		if err := json.Unmarshal(wrapper.Data, &d); err != nil {
			return nil, err
		}
		result = &d
	case DataTypeTracing:
		var d TracingData
		if err := json.Unmarshal(wrapper.Data, &d); err != nil {
			return nil, err
		}
		result = &d
	default:
		return nil, nil
	}

	return result, nil
}
