package analyzer

import (
	"context"
	"fmt"
	"io"
	"path/filepath"

	"github.com/perf-analysis/pkg/model"
)

// JavaCPUAnalyzer analyzes Java async-profiler CPU data.
type JavaCPUAnalyzer struct {
	*BaseAnalyzer
}

// NewJavaCPUAnalyzer creates a new Java CPU analyzer.
func NewJavaCPUAnalyzer(config *BaseAnalyzerConfig) *JavaCPUAnalyzer {
	return &JavaCPUAnalyzer{
		BaseAnalyzer: NewBaseAnalyzer(config),
	}
}

// Name returns the analyzer name.
func (a *JavaCPUAnalyzer) Name() string {
	return "java_cpu_analyzer"
}

// SupportedTypes returns the task types supported by this analyzer.
func (a *JavaCPUAnalyzer) SupportedTypes() []model.TaskType {
	return []model.TaskType{model.TaskTypeJava}
}

// Analyze performs Java CPU profiling analysis.
func (a *JavaCPUAnalyzer) Analyze(ctx context.Context, req *model.AnalysisRequest, dataReader io.Reader) (*model.AnalysisResult, error) {
	// Only handle CPU profiling (profiler type 0)
	if req.ProfilerType != model.ProfilerTypePerf {
		return nil, fmt.Errorf("java cpu analyzer only supports profiler type perf, got %v", req.ProfilerType)
	}

	// Step 1: Parse the collapsed data
	parseResult, err := a.Parse(ctx, dataReader)
	if err != nil {
		return nil, fmt.Errorf("%w: %v", ErrParseError, err)
	}

	if parseResult.TotalSamples == 0 {
		return nil, ErrEmptyData
	}

	// Step 2: Ensure output directory
	taskDir, err := a.EnsureOutputDir(req.TaskUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to create output directory: %w", err)
	}

	// Step 3: Generate flame graph
	fg, err := a.GenerateFlameGraph(ctx, parseResult.Samples)
	if err != nil {
		return nil, fmt.Errorf("failed to generate flame graph: %w", err)
	}

	flameGraphFile := filepath.Join(taskDir, "collapsed_data.json.gz")
	if err := a.WriteFlameGraphGzip(fg, flameGraphFile); err != nil {
		return nil, fmt.Errorf("failed to write flame graph: %w", err)
	}

	// Step 4: Generate call graph
	cg, err := a.GenerateCallGraph(ctx, parseResult.Samples)
	if err != nil {
		return nil, fmt.Errorf("failed to generate call graph: %w", err)
	}

	callGraphFile := filepath.Join(taskDir, "collapsed_data.json")
	if err := a.WriteCallGraphJSON(cg, callGraphFile); err != nil {
		return nil, fmt.Errorf("failed to write call graph: %w", err)
	}

	// Step 5: Calculate statistics
	topFuncsResult := a.CalculateTopFuncs(parseResult.Samples)
	threadStatsResult := a.CalculateThreadStats(parseResult.Samples)

	// Step 6: Collect suggestions from parse result
	suggestions := parseResult.Suggestions
	if suggestions == nil {
		suggestions = make([]model.Suggestion, 0)
	}

	// Step 7: Build namespace result
	nsResult, err := a.BuildNamespaceResult(
		req.TaskUUID,
		parseResult,
		topFuncsResult,
		threadStatsResult,
		req.TaskUUID+"/collapsed_data.json.gz",
		req.TaskUUID+"/collapsed_data.json",
		suggestions,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to build namespace result: %w", err)
	}

	// Step 8: Build analysis result
	result := &model.AnalysisResult{
		TaskUUID:       req.TaskUUID,
		ContainersInfo: make(map[string]model.ContainerInfo),
		Result: map[string]model.NamespaceResult{
			"": *nsResult,
		},
		TotalRecords:            parseResult.TotalSamples,
		TotalRecordsWithSwapper: parseResult.TotalSamples,
	}

	return result, nil
}

// GetOutputFiles returns the list of output files generated by the analyzer.
func (a *JavaCPUAnalyzer) GetOutputFiles(taskUUID, taskDir string) []OutputFile {
	return []OutputFile{
		{LocalPath: filepath.Join(taskDir, "collapsed_data.json.gz"), COSKey: taskUUID + "/collapsed_data.json.gz"},
		{LocalPath: filepath.Join(taskDir, "collapsed_data.json"), COSKey: taskUUID + "/collapsed_data.json"},
	}
}

// OutputFile represents a file to be uploaded.
type OutputFile struct {
	LocalPath string
	COSKey    string
}
